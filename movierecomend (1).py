# -*- coding: utf-8 -*-
"""movierecomend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hqZ6AG1kZ4G7OgDn_zSzklsEjJD4RPJg
"""

!pip install pandas nltk scikit-learn

import nltk
nltk.download('punkt')         # for tokenizing text into words
nltk.download('stopwords')     # for filtering out common English words

import pandas as pd
import ast

# Load the movie and credits datasets
movies_df = pd.read_csv("/content/tmdb_5000_movies.csv")
credits_df = pd.read_csv("/content/tmdb_5000_credits.csv")

# Merge them on 'title' so we can get actors + genres + overview in one row
df = movies_df.merge(credits_df, on='title')

df.head()

df.info()

df.isnull().sum()

dfs = df.dropna(subset=["homepage", "overview", "release_date", "runtime", "tagline"])
dfs = dfs.drop(columns=["homepage", "tagline","budget"])

dfs

from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
import string

stop_words = set(stopwords.words('english'))  # create a set for fast lookup

def clean_text(text):
    if not isinstance(text, str):
        return ''
    tokens = word_tokenize(text.lower())               # convert to lowercase and tokenize
    tokens = [word for word in tokens if word.isalnum()]  # keep only letters/numbers (remove punctuation)
    tokens = [word for word in tokens if word not in stop_words]  # remove stopwords
    return " ".join(tokens)   # join back to string

def extract_genres(genre_str):
    return " ".join([g['name'] for g in ast.literal_eval(genre_str)])

def extract_actors(cast_str):
    return " ".join([a['name'] for a in ast.literal_eval(cast_str)[:3]])  # Top 5 actors

import nltk
nltk.download('punkt_tab')

df['genres_clean'] = df['genres'].apply(extract_genres).str.lower()
df['actors_clean'] = df['cast'].apply(extract_actors).str.lower()
df['overview'] = df['overview'].fillna('').str.lower()

df['combined'] = df['overview'] + ' ' + df['genres_clean'] + ' ' + df['actors_clean']
df['combined_clean'] = df['combined'].apply(clean_text)

from sklearn.feature_extraction.text import TfidfVectorizer

vectorizer = TfidfVectorizer()
tfidf_matrix = vectorizer.fit_transform(df['combined_clean'])

from sklearn.metrics.pairwise import cosine_similarity

cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

df = df.reset_index()
title_to_index = pd.Series(df.index, index=df['title'].str.lower())

def recommend_movie(title, top_n=10):
    title = title.lower()
    if title not in title_to_index:
        return f"'{title}' not found in dataset."

    idx = title_to_index[title]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:top_n + 1]  # skip the first (itself)

    movie_indices = [i[0] for i in sim_scores]
    return df['title'].iloc[movie_indices].tolist()

from collections import defaultdict
import difflib

actor_to_movies = defaultdict(list)

# Map each actor word (first name, last name) to the movie title
for i, row in df.iterrows():
    for actor in row['actors_clean'].split():
        actor_to_movies[actor].append(row['title'])

def search_actor(actor_query):
    actor_query = actor_query.lower()
    matches = difflib.get_close_matches(actor_query, actor_to_movies.keys(), n=3, cutoff=0.5)
    return matches

def recommend_by_actor(actor_query, max_movies=10):
    matched = search_actor(actor_query)
    if not matched:
        return f"No actor matched '{actor_query}'"

    movies = []
    for actor in matched:
        movies.extend(actor_to_movies[actor])
    return list(set(movies))[:max_movies]

print("ðŸŽ¬ Movie-Based Recommendations for 'Action':")
print(recommend_movie("Horror", 5))

print("\nðŸ‘¤ Actor-Based Recommendations for 'rdj':")
print(recommend_by_actor("Jake Sully", 5))

def recommend_by_genre(genre_query, top_n=10):
    genre_query = genre_query.lower()
    # Check if genre exists in any movie
    matches = df[df['genres_clean'].str.contains(genre_query)]

    if matches.empty:
        return f"'{genre_query}' not found in dataset."

    # Return top N movies from that genre
    return matches['title'].head(top_n).tolist()

print(recommend_by_genre("action", 5))

user_liked = ["Interstellar", "The Matrix", "The Dark Knight"]

recommendations = recommend_movie("Inception", 10)  # top 10 recommended

# Precision@K
hits = [movie for movie in recommendations if movie in user_liked]
precision = len(hits) / len(recommendations)

print("Recommended:", recommendations)
print("Relevant:", user_liked)
print(f"Precision@10: {precision:.2f}")

hit_rate = int(any(movie in user_liked for movie in recommendations))
print("Hit Rate:", hit_rate)

